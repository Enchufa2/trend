General Description
===================

trend is a general-purpose, efficient trend graph for "live" data. Data is read
in ASCII form from a file or continuously from a FIFO and displayed in
real-time into a multipass trend (much like a CRT oscilloscope). trend can be
used as a rapid analysis tool for progressive or time-based data series
together with trivial scripting.

Features:

- OpenGL graphics
- Automatic or fixed graph scaling
- Two graph scrolling and shading modes
- Configurable colours/grid

Requires:

- OpenGL
- GLUT (http://www.opengl.org/resources/libraries/glut.html) or
  FreeGLUT (http://freeglut.sourceforge.net/)
- A recent C++ compiler
- POSIX system


Building
========

Type "make" in the source distribution. The executable "trend" will be created.
The Makefile is still in embryonic form, so it supports only gcc/IRIX systems
for now. Any POSIX/OpenGL capable system should be supported.


Executing
=========

Data:

The data is a space/tab/newline-separated series of ASCII decimal numbers; es:

  1 2 3 4
  5.1 6 0x12
  -12.4E5

The parser is very lenient, and will silently ignore whatever looks like
garbage.

FIFO:

To display real-time data you should create a special FIFO file using the
mkfifo command:

  mkfifo fifofilename

and redirect your script's output to that file. FIFOs are automatically
re-opened upon EOF. Alternatively you can store your data in a plain file and
simply display its last values non-interactively.

Executing:

Execute trend as follows:

  ./trend [options] fifofilename history-size subdivisions [low high]

where:

- options is a list of optional flags (explained later)
- fifofilename is the named fifo you just created.
- history-size is the total number of values the graph will retain in the graph
  before discarding the old ones.
- subdivisions is the number of horizontal subdivisions of the graph. Older
  values will wrap around (you can still see them under newer ones).
- low and high are the optional graph vertical limits (respectively the lower
  and upper limits). If none are specified the graph will auto-scale itself.

When new data arrives, the value is plotted and the cursor position is
advanced. That is, the graph scrolling speed is determined by the speed of the
data flow (for now at least).

Options:

 -d		dimmed shading mode
 -S		enable antialiasing
 -s		"scrolling" mode
 -v		visible values
 -m		visible marker
 -g		visible grid
 -G n		specify grid resolution
 -h		help and version info
 -t str		specify a window title
 -A colour	background colour
 -E colour	text (values) colour
 -R colour	grid colour
 -I colour	trend colour
 -M colour	marker colour

Shading modes:

The default is to shade uniformly old values to complete transparency. The
"dimmed" shading mode draws the foreground values with full opacity and the
others with half opacity.

Colour spec:

A colour is specified in hex RGB format, as follows: #RRGGBB (with or without #).
Some examples:

  #FF0000: red
  #00FF00: green
  #A020F0: purple

Scrolling modes:

The default visualisation mode is "wrap-around": newer values will simply wrap
around the screen when new data arrives. The other one is "scrolling": new data
is always placed at the right edge of the screen, and older values scrolled on
the left.

Values:

Three value indicators are drawn on the screen: upper limit, lower limit and
current data value (respectively on the upper right, lower right and lower left
of the screen).

Interactive keys:

- ESC: quit/exit
- a: toggle auto-scaling
- d: toggle dimmed shading mode
- S: toggle anti-aliasing
- s: switch scrolling mode (wrap-around or scrolling)
- v: toggle values
- m: activate a marker on the current cursor position
- g: toggle grid
- G: change grid resolution (enter the new resolution on the console).

Autoscaling:

When autoscaling is enabled the graph will be scaled vertically to fit visible
values. The grid resolution is used to add some vertical bounds to the
graph. Disabling autoscaling interactively will retain current limits.


Examples
========

Some very sample introductory scripts are included within the package:

./mem <microseconds>:

  Print-out used memory (incl. swap) of a linux kernel using /proc/meminfo
  using Perl each tenth of second or the specified number of microseconds.

./net <microseconds> [if]:

  Show cumulative (in + out) network consumption in bytes using /proc/net/dev
  using Perl (defaults to eth0).

./tstimes:

  A more complicated example I use to display server production times without
  particular requirements (the log is parsed and displayed in realtime)

In the following example we will display the latest two minutes of network
activity (with the first one being in front of the other) sampled each tenth of
second:

  mkfifo fifo
  ./trend fifo 1200 600 &
  ./net 100000 > fifo

To display the number of current active processes over time you can do:

  (while true; do ps -A | wc -l; sleep 1; done) > fifo

etc.


Authors and Copyright
=====================

trend is distributed under LGPL (see COPYING) WITHOUT ANY WARRANY.
Copyright(c) 2003-2004 by wave++ "Yuri D'Elia" <wavexx@users.sf.net>
Suggestions/comments are welcome. A new version of trend is coming out shortly,
so don't hesitate.
